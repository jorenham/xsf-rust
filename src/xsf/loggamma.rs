mod sealed {
    pub trait Sealed {}
    impl Sealed for f64 {}
    impl Sealed for num_complex::Complex<f64> {}
}

pub trait LogGammaArg: sealed::Sealed {
    fn xsf_loggamma(self) -> Self;
    fn xsf_rgamma(self) -> Self;
}

impl LogGammaArg for f64 {
    #[inline(always)]
    fn xsf_loggamma(self) -> f64 {
        unsafe { crate::ffi::xsf::loggamma(self) }
    }
    #[inline(always)]
    fn xsf_rgamma(self) -> f64 {
        unsafe { crate::ffi::xsf::rgamma(self) }
    }
}

impl LogGammaArg for num_complex::Complex<f64> {
    #[inline(always)]
    fn xsf_loggamma(self) -> Self {
        unsafe { crate::ffi::xsf::loggamma_1(self) }
    }
    #[inline(always)]
    fn xsf_rgamma(self) -> Self {
        unsafe { crate::ffi::xsf::rgamma_1(self) }
    }
}

/// Principal branch of the logarithm of `gamma(z)`
#[doc(alias = "lgamma")]
#[doc(alias = "ln_gamma")]
#[doc(alias = "log_gamma")]
pub fn loggamma<T: LogGammaArg>(z: T) -> T {
    z.xsf_loggamma()
}

/// Reciprocal Gamma function `1 / gamma(z)`
pub fn rgamma<T: LogGammaArg>(z: T) -> T {
    z.xsf_rgamma()
}

#[cfg(test)]
mod tests {
    use num_complex::c64;

    #[test]
    fn test_loggamma_f64() {
        crate::xsref::test("loggamma", "d-d", |x| crate::loggamma(x[0]));
    }

    #[test]
    fn test_loggamma_c64() {
        crate::xsref::test("loggamma", "cd-cd", |x| crate::loggamma(c64(x[0], x[1])));
    }

    #[test]
    fn test_rgamma_f64() {
        crate::xsref::test("rgamma", "d-d", |x| crate::rgamma(x[0]));
    }

    #[test]
    fn test_rgamma_c64() {
        crate::xsref::test("rgamma", "cd-cd", |x| crate::rgamma(c64(x[0], x[1])));
    }
}
