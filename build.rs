use std::env;
use std::path::PathBuf;

const WRAPPER_NAME: &str = "xsf_wrapper";
const WRAPPER_PREAMBLE: &str = "// generated by build.rs -- do not edit\n\n";

const XSF_HEADERS: &[&str] = &[
    // "airy.h",
    "alg.h",
    // "bessel.h",
    "beta.h",
    "binom.h",
    // "cdflib.h",
    "digamma.h",
    // "ellip.h",
    "erf.h",
    // "evalpoly.h"
    "exp.h",
    "expint.h",
    // "fresnel.h",
    "gamma.h",
    "hyp2f1.h",
    "iv_ratio.h",
    "kelvin.h",
    // "lambertw.h",
    "legendre.h",
    "log_exp.h",
    "log.h",
    "loggamma.h",
    "mathieu.h",
    // "par_cyl.h",
    // "recur.h",
    // "sici.h",
    "specfun.h",
    // "sph_bessel.h",
    // "sph_harm.h",
    "sphd_wave.h",
    "stats.h",
    "struve.h",
    "trig.h",
    "wright_bessel.h",
    "zeta.h",
];
const XSF_SIGNATURES: &[(&str, &str)] = &[
    // alg.h
    ("cbrt", "double x"),
    // beta.h
    ("beta", "double a, double b"),
    ("betaln", "double a, double b"),
    // binom.h
    // cdflib.h  (TODO: `gdtrib`)
    ("binom", "double n, double k"),
    // digamma.h
    ("digamma", "double z"),
    // erf.h
    ("erf", "double x"),
    ("erfc", "double x"),
    ("erfcx", "double x"),
    ("erfi", "double x"),
    ("voigt_profile", "double x, double sigma, double gamma"),
    ("dawsn", "double x"),
    // evalpoly.h  (TODO: `cevalpoly`)
    // exp.h
    ("expm1", "double x"),
    ("exp2", "double x"),
    ("exp10", "double x"),
    // expint.h
    ("exp1", "double x"),
    ("expi", "double x"),
    ("scaled_exp1", "double x"),
    // fresnel.h  (TODO: `fresnel`, `fcszo`)
    // gamma.h
    ("gamma", "double x"), // TODO: complex
    ("gammaln", "double x"),
    ("gammasgn", "double x"),
    ("gammainc", "double a, double x"),
    ("gammaincinv", "double a, double p"),
    ("gammaincc", "double a, double x"),
    ("gammainccinv", "double a, double p"),
    ("gamma_ratio", "double a, double b"),
    // hyp2f1.h
    ("hyp2f1", "double a, double b, double c, double x"), // TODO: complex
    // iv_ratio.h
    ("iv_ratio", "double v, double x"),
    ("iv_ratio_c", "double v, double x"),
    // kelvin.h (TODO: `kelvin`, `klvnzo`)
    ("ber", "double x"),
    ("bei", "double x"),
    ("ker", "double x"),
    ("kei", "double x"),
    ("berp", "double x"),
    ("beip", "double x"),
    ("kerp", "double x"),
    ("keip", "double x"),
    // legendre.h  (TODO: `assoc_legendre_p`, `lqn`, `lqmn`)
    ("legendre_p", "int n, double z"),
    ("sph_legendre_p", "int n, int m, double theta"),
    // log_exp.h
    ("expit", "double x"),
    ("exprel", "double x"),
    ("logit", "double x"),
    ("log_expit", "double x"),
    ("log1mexp", "double x"),
    // log.h
    ("log1p", "double x"),
    ("log1pmx", "double x"),
    ("xlogy", "double x, double y"),
    ("xlog1py", "double x, double y"),
    // loggamma.h
    ("loggamma", "double x"),
    ("rgamma", "double z"),
    // mathieu.h  (TODO: `cen`, `sem`, `mcm1`, `msm1`, `mcm2`, `msm2`)
    ("cem_cva", "double m, double q"),
    ("sem_cva", "double m, double q"),
    // specfun.h  (TODO: `chyp2f1`, `cerf`)
    ("hypu", "double a, double b, double x"),
    ("hyp1f1", "double a, double b, double x"),
    ("pmv", "double m, double v, double x"),
    // sphd_wave.h
    ("prolate_segv", "double m, double n, double c"),
    ("oblate_segv", "double m, double n, double c"),
    // stats.h
    ("bdtr", "double k, int n, double p"),
    ("bdtrc", "double k, int n, double p"),
    ("bdtri", "double k, int n, double y"),
    ("chdtr", "double df, double x"),
    ("chdtrc", "double df, double x"),
    ("chdtri", "double df, double y"),
    ("fdtr", "double a, double b, double x"),
    ("fdtrc", "double a, double b, double x"),
    ("fdtri", "double a, double b, double y"),
    ("gdtr", "double a, double b, double x"),
    ("gdtrc", "double a, double b, double x"),
    ("kolmogorov", "double x"),
    ("kolmogc", "double x"),
    ("kolmogi", "double x"),
    ("kolmogp", "double x"),
    ("ndtr", "double x"),
    ("ndtri", "double x"),
    ("log_ndtr", "double x"),
    ("nbdtr", "int k, int n, double p"),
    ("nbdtrc", "int k, int n, double p"),
    ("nbdtri", "int k, int n, double p"),
    ("owens_t", "double h, double a"),
    ("pdtr", "double k, double m"),
    ("pdtrc", "double k, double m"),
    ("pdtri", "int k, double y"),
    ("smirnov", "int n, double x"),
    ("smirnovc", "int n, double x"),
    ("smirnovi", "int n, double x"),
    ("smirnovp", "int n, double x"),
    ("tukeylambdacdf", "double x, double lmbda"),
    // struve.h
    ("itstruve0", "double x"),
    ("it2struve0", "double x"),
    ("itmodstruve0", "double x"),
    ("struve_h", "double v, double z"),
    ("struve_l", "double v, double z"),
    // trig.h
    ("sinpi", "double x"),
    ("cospi", "double x"),
    ("sindg", "double x"),
    ("cosdg", "double x"),
    ("tandg", "double x"),
    ("cotdg", "double x"),
    ("radian", "double d, double m, double s"),
    ("cosm1", "double x"),
    // wright_bessel.h
    // ("wright_bessel_t", "double a, double b, double x"),
    ("wright_bessel", "double a, double b, double x"),
    ("log_wright_bessel", "double a, double b, double x"),
    // zeta.h
    ("riemann_zeta", "double x"),
    ("zeta", "double x, double q"),
    ("zetac", "double x"),
];

fn push_line(source: &mut String, line: &str) {
    source.push_str(line);
    source.push('\n');
}

fn generate_header(dir_out: &str) -> String {
    let mut source = String::from(WRAPPER_PREAMBLE);

    push_line(&mut source, "#pragma once");
    push_line(&mut source, "");
    push_line(&mut source, "extern \"C\" {");
    for (name, params) in XSF_SIGNATURES {
        push_line(&mut source, &format!("    double xsf_{name}({params});"));
    }
    push_line(&mut source, "}");

    let file = format!("{dir_out}/{WRAPPER_NAME}.hpp");
    std::fs::write(&file, source).unwrap();
    file
}

fn build_wrapper(dir_out: &str, header: &str, include: &str) {
    let mut source = String::from(WRAPPER_PREAMBLE);

    push_line(&mut source, &format!("#include \"{header}\""));
    for xsf_header in XSF_HEADERS {
        push_line(&mut source, &format!("#include \"xsf/{xsf_header}\""));
    }
    push_line(&mut source, "");

    push_line(&mut source, "extern \"C\" {");
    for (name, params) in XSF_SIGNATURES {
        let args = params
            .split(',')
            .map(|param| param.split_whitespace().last().unwrap_or(""))
            .collect::<Vec<_>>()
            .join(", ");

        push_line(
            &mut source,
            &format!("    double xsf_{name}({params}) {{ return xsf::{name}({args}); }}"),
        );
    }
    push_line(&mut source, "}");

    let file_cpp = format!("{dir_out}/{WRAPPER_NAME}.cpp");
    std::fs::write(&file_cpp, source).unwrap();

    cc::Build::new()
        .cpp(true)
        .std("c++17")
        .flag_if_supported("-Wno-unused-parameter")
        .flag_if_supported("-Wno-logical-op-parentheses")
        .file(file_cpp)
        .include(include)
        .compile(WRAPPER_NAME);
}

fn generate_bindings(dir_out: &str, file_hpp: &str) {
    bindgen::Builder::default()
        .header(file_hpp)
        .allowlist_function("xsf_.*")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .generate()
        .unwrap()
        .write_to_file(PathBuf::from(dir_out).join("bindings.rs"))
        .unwrap();
}

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    let include = format!("{manifest_dir}/xsf/include");
    let header = generate_header(&out_dir);

    println!("cargo:rerun-if-changed={include}");

    build_wrapper(&out_dir, &header, &include);
    generate_bindings(&out_dir, &header);
}
