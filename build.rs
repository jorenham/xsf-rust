use core::panic;
use std::env;
use std::path::PathBuf;

const WRAPPER_NAME: &str = "xsf_wrapper";
const WRAPPER_PREAMBLE: &str = "// generated by build.rs -- do not edit\n\n";

const XSF_HEADERS: &[&str] = &[
    // "airy.h",
    "alg.h",
    "bessel.h",
    "beta.h",
    "binom.h",
    "cdflib.h",
    "digamma.h",
    "ellip.h",
    "erf.h",
    // "evalpoly.h"
    "exp.h",
    "expint.h",
    // "fresnel.h",
    "gamma.h",
    "hyp2f1.h",
    "iv_ratio.h",
    "kelvin.h",
    // "lambertw.h",
    "legendre.h",
    "log_exp.h",
    "log.h",
    "loggamma.h",
    "mathieu.h",
    // "par_cyl.h",
    // "recur.h",
    // "sici.h",
    "specfun.h",
    // "sph_bessel.h",
    // "sph_harm.h",
    "sphd_wave.h",
    "stats.h",
    "struve.h",
    "trig.h",
    "wright_bessel.h",
    "zeta.h",
];
// e.g. `("spam", "if->d")` becomes `double xsf_spam(int x0, float x1)`
const XSF_TYPES: &[(&str, &str)] = &[
    // airy.h
    // TODO: `airyb`, `airyzo`, `airy`, `airye`, `itairy`
    ("cbrt", "d->d"),
    // bessel.h
    // TODO: `it1j0y0`, `it2j0y0`, `it1i0k0`, `it2i0k0`
    // TODO: `rctj`, `rcty`,
    ("cyl_bessel_j", "dd->d"),
    ("cyl_bessel_j", "dD->D"),
    ("cyl_bessel_je", "dd->d"),
    ("cyl_bessel_je", "dD->D"),
    ("cyl_bessel_j0", "d->d"),
    ("cyl_bessel_j1", "d->d"),
    ("cyl_bessel_y", "dd->d"),
    ("cyl_bessel_y", "dD->D"),
    ("cyl_bessel_ye", "dd->d"),
    ("cyl_bessel_ye", "dD->D"),
    ("cyl_bessel_y0", "d->d"),
    ("cyl_bessel_y1", "d->d"),
    ("cyl_bessel_i", "dd->d"),
    ("cyl_bessel_i", "dD->D"),
    ("cyl_bessel_ie", "dd->d"),
    ("cyl_bessel_ie", "dD->D"),
    ("cyl_bessel_i0", "d->d"),
    ("cyl_bessel_i0e", "d->d"),
    ("cyl_bessel_i1", "d->d"),
    ("cyl_bessel_i1e", "d->d"),
    ("cyl_bessel_k", "dd->d"),
    ("cyl_bessel_k", "dD->D"),
    ("cyl_bessel_ke", "dd->d"),
    ("cyl_bessel_ke", "dD->D"),
    ("cyl_bessel_k0", "d->d"),
    ("cyl_bessel_k0e", "d->d"),
    ("cyl_bessel_k1", "d->d"),
    ("cyl_bessel_k1e", "d->d"),
    ("cyl_hankel_1", "dD->D"),
    ("cyl_hankel_1e", "dD->D"),
    ("cyl_hankel_2", "dD->D"),
    ("cyl_hankel_2e", "dD->D"),
    ("besselpoly", "ddd->d"),
    // beta.h
    ("beta", "dd->d"),
    ("betaln", "dd->d"),
    // binom.h
    ("binom", "dd->d"),
    // cdflib.h
    ("gdtrib", "ddd->d"),
    // digamma.h
    ("digamma", "d->d"),
    ("digamma", "D->D"),
    // ellip.h
    // TODO: ellipj
    ("ellipk", "d->d"),
    ("ellipkm1", "d->d"),
    ("ellipkinc", "dd->d"),
    ("ellipe", "d->d"),
    ("ellipeinc", "dd->d"),
    // erf.h
    ("erf", "d->d"),
    ("erf", "D->D"),
    ("erfc", "d->d"),
    ("erfc", "D->D"),
    ("erfcx", "d->d"),
    ("erfcx", "D->D"),
    ("erfi", "d->d"),
    ("erfi", "D->D"),
    ("voigt_profile", "ddd->d"),
    ("wofz", "D->D"),
    ("dawsn", "d->d"),
    ("dawsn", "D->D"),
    // evalpoly.h
    // TODO: `cevalpoly`
    // expint.h
    ("expm1", "d->d"),
    ("exp2", "d->d"),
    ("exp10", "d->d"),
    ("exp1", "d->d"),
    ("expi", "d->d"),
    ("scaled_exp1", "d->d"),
    // fresnel.h
    // TODO: `fresnel`, `fcszo`
    // gamma.h
    ("gamma", "d->d"), // TODO: complex
    ("gammaln", "d->d"),
    ("gammasgn", "d->d"),
    ("gammainc", "dd->d"),
    ("gammaincinv", "dd->d"),
    ("gammaincc", "dd->d"),
    ("gammainccinv", "dd->d"),
    // hyp2f1.h
    ("hyp2f1", "dddd->d"), // TODO: complex
    // iv_ratio.h
    ("iv_ratio", "dd->d"),
    ("iv_ratio_c", "dd->d"),
    // kelvin.h
    // TODO: `kelvin`, `klvnzo`
    ("ber", "d->d"),
    ("bei", "d->d"),
    ("ker", "d->d"),
    ("kei", "d->d"),
    ("berp", "d->d"),
    ("beip", "d->d"),
    ("kerp", "d->d"),
    ("keip", "d->d"),
    // legendre.h
    // TODO: `assoc_legendre_p`, `lqn`, `lqmn`
    ("legendre_p", "id->d"),
    ("sph_legendre_p", "iid->d"),
    // log_exp.h
    ("expit", "d->d"),
    ("exprel", "d->d"),
    ("logit", "d->d"),
    ("log_expit", "d->d"),
    ("log1mexp", "d->d"),
    // log.h
    ("log1pmx", "d->d"),
    ("xlogy", "dd->d"),
    ("xlog1py", "dd->d"),
    // loggamma.h
    ("loggamma", "d->d"),
    ("rgamma", "d->d"),
    // mathieu.h
    // TODO: `cen`, `sem`, `mcm1`, `msm1`, `mcm2`, `msm2`
    ("cem_cva", "dd->d"),
    ("sem_cva", "dd->d"),
    // specfun.h
    // TODO: `chyp2f1`, `cerf`
    ("hypu", "ddd->d"),
    ("hyp1f1", "ddd->d"),
    ("pmv", "ddd->d"),
    // sphd_wave.h
    ("prolate_segv", "ddd->d"),
    ("oblate_segv", "ddd->d"),
    // stats.h
    ("bdtr", "did->d"),
    ("bdtrc", "did->d"),
    ("bdtri", "did->d"),
    ("chdtr", "dd->d"),
    ("chdtrc", "dd->d"),
    ("chdtri", "dd->d"),
    ("fdtr", "ddd->d"),
    ("fdtrc", "ddd->d"),
    ("fdtri", "ddd->d"),
    ("gdtr", "ddd->d"),
    ("gdtrc", "ddd->d"),
    ("kolmogorov", "d->d"),
    ("kolmogc", "d->d"),
    ("kolmogi", "d->d"),
    ("kolmogp", "d->d"),
    ("ndtr", "d->d"),
    ("ndtri", "d->d"),
    ("log_ndtr", "d->d"),
    ("nbdtr", "iid->d"),
    ("nbdtrc", "iid->d"),
    ("nbdtri", "iid->d"),
    ("owens_t", "dd->d"),
    ("pdtr", "dd->d"),
    ("pdtrc", "dd->d"),
    ("pdtri", "id->d"),
    ("smirnov", "id->d"),
    ("smirnovc", "id->d"),
    ("smirnovi", "id->d"),
    ("smirnovp", "id->d"),
    ("tukeylambdacdf", "dd->d"),
    // struve.h
    ("itstruve0", "d->d"),
    ("it2struve0", "d->d"),
    ("itmodstruve0", "d->d"),
    ("struve_h", "dd->d"),
    ("struve_l", "dd->d"),
    // trig.h
    ("sinpi", "d->d"),
    ("cospi", "d->d"),
    ("sindg", "d->d"),
    ("cosdg", "d->d"),
    ("tandg", "d->d"),
    ("cotdg", "d->d"),
    ("radian", "ddd->d"),
    ("cosm1", "d->d"),
    // wright_bessel.h
    ("wright_bessel", "ddd->d"),
    ("log_wright_bessel", "ddd->d"),
    // zeta.h
    ("riemann_zeta", "d->d"),
    ("zeta", "dd->d"),
    ("zetac", "d->d"),
];
// Functions that need renaming because they clash with standard library names
const XSF_RENAME: &[(&str, &str)] = &[
    ("cbrt", "cbrt_"),
    ("gamma", "gamma_"),
    ("erf", "erf_"),
    ("erfc", "erfc_"),
    ("expm1", "expm1_"),
    ("exp2", "exp2_"),
    ("exp10", "exp10_"),
];

fn get_ctype(code: char) -> &'static str {
    match code {
        'i' => "int",
        'f' => "float",
        'd' => "double",
        'F' => "std::complex<float>",
        'D' => "std::complex<double>",
        'V' => "void",
        _ => panic!("Unknown parameter type"),
    }
}

fn fmt_params(spec: &str, types: bool) -> String {
    // TODO: >1 outputs, e.g. `ii->di` => `void _(int x0, int x1, double &y0, int &y1)`
    spec.split("->")
        .next()
        .unwrap()
        .chars()
        .enumerate()
        .map(if types {
            |(i, p)| format!("{} x{}", get_ctype(p), i)
        } else {
            |(i, _)| format!("x{}", i)
        })
        .collect::<Vec<_>>()
        .join(", ")
}

fn fmt_return(types: &str) -> String {
    let chars = types.split("->").last().unwrap();
    assert!(chars.len() == 1, "Multiple return values not supported");
    get_ctype(chars.chars().next().unwrap()).to_string()
}

fn fmt_func(name: &str, types: &str, suffix: &str) -> String {
    let ret = fmt_return(types);
    let params = fmt_params(types, true);
    let base_name = XSF_RENAME
        .iter()
        .find(|(n, _)| *n == name)
        .map(|(_, r)| *r)
        .unwrap_or(name);
    let func_name = if suffix.is_empty() {
        base_name.to_string()
    } else {
        format!("{}_{}", base_name, suffix)
    };
    format!("{} {}({})", ret, func_name, params)
}

fn fmt_call(name: &str, types: &str) -> String {
    let args = fmt_params(types, false);
    format!("xsf::{}({})", name, args)
}

fn push_line(source: &mut String, line: &str) {
    source.push_str(line);
    source.push('\n');
}

fn generate_header(dir_out: &str) -> String {
    let mut source = String::from(WRAPPER_PREAMBLE);

    push_line(&mut source, "#pragma once");
    push_line(&mut source, "#include <complex>");

    // Generate unique function names for overloads
    let mut name_counts = std::collections::HashMap::new();
    for (name, types) in XSF_TYPES {
        let count = name_counts.entry(*name).or_insert(0);
        let suffix = if *count == 0 { "" } else { &count.to_string() };
        let func_decl = fmt_func(name, types, suffix);
        push_line(&mut source, &format!("{func_decl};"));
        *count += 1;
    }

    let file = format!("{dir_out}/{WRAPPER_NAME}.hpp");
    std::fs::write(&file, source).unwrap();
    file
}

fn build_wrapper(dir_out: &str, include: &str) {
    let mut source = String::from(WRAPPER_PREAMBLE);

    push_line(&mut source, &format!("#include \"{WRAPPER_NAME}.hpp\""));
    for xsf_header in XSF_HEADERS {
        push_line(&mut source, &format!("#include \"xsf/{xsf_header}\""));
    }

    // Generate unique function implementations for overloads
    let mut name_counts = std::collections::HashMap::new();
    for (name, types) in XSF_TYPES {
        let count = name_counts.entry(*name).or_insert(0);
        let suffix = if *count == 0 { "" } else { &count.to_string() };
        let func_decl = fmt_func(name, types, suffix);
        let call = fmt_call(name, types);
        push_line(&mut source, &format!("{func_decl} {{ return {call}; }}"));
        *count += 1;
    }

    let file_cpp = format!("{dir_out}/{WRAPPER_NAME}.cpp");
    std::fs::write(&file_cpp, source).unwrap();

    cc::Build::new()
        .cpp(true)
        .std("c++17")
        .flag_if_supported("-Wno-unused-parameter")
        .flag_if_supported("-Wno-logical-op-parentheses")
        .file(file_cpp)
        .include(include)
        .compile(WRAPPER_NAME);
}

fn generate_bindings(dir_out: &str, header: &str) {
    // Generate allowlist pattern including numbered overloads
    let mut allowlist_functions = Vec::new();
    let mut name_counts = std::collections::HashMap::new();

    for (name, _) in XSF_TYPES {
        let count = name_counts.entry(*name).or_insert(0);
        let base_name = XSF_RENAME
            .iter()
            .find(|(n, _)| n == name)
            .map(|(_, r)| *r)
            .unwrap_or(name);

        if *count == 0 {
            allowlist_functions.push(base_name.to_string());
        } else {
            allowlist_functions.push(format!("{}_{}", base_name, count));
        }
        *count += 1;
    }

    let allowlist_pattern = allowlist_functions.join("|");

    bindgen::Builder::default()
        .header(header)
        .size_t_is_usize(true)
        .sort_semantically(true)
        .opaque_type("std::*")
        .allowlist_function(&allowlist_pattern)
        .blocklist_type("std::complex_value_type")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .generate()
        .unwrap()
        .write_to_file(PathBuf::from(dir_out).join("bindings.rs"))
        .unwrap();
}

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    let include = format!("{manifest_dir}/xsf/include");
    let header = generate_header(&out_dir);

    println!("cargo:rerun-if-changed={include}");

    build_wrapper(&out_dir, &include);
    generate_bindings(&out_dir, &header);
}
