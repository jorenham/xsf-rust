use std::collections::HashMap;
use std::path::PathBuf;
use std::{env, fs};

const CXX_STANDARD: &str = "c++17";

const XSF_INCLUDE: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/xsf/include");

const WRAPPER_NAME: &str = "xsf_wrapper";
const WRAPPER_PREAMBLE: &str = "// generated by build.rs -- do not edit\n\n";
const WRAPPER_INCLUDES: &[&str] = &[
    "cephes/erfinv.h",
    "cephes/expn.h",
    "cephes/incbet.h",
    "cephes/incbi.h",
    "cephes/lanczos.h",
    "cephes/poch.h",
    "cephes/round.h",
    "cephes/spence.h",
    "cephes/unity.h",
    "specfun/specfun.h",
    "airy.h",
    "alg.h",
    "bessel.h",
    "beta.h",
    "binom.h",
    "cdflib.h",
    "digamma.h",
    "ellip.h",
    "erf.h",
    "evalpoly.h",
    "exp.h",
    "expint.h",
    "fp_error_metrics.h",
    "fresnel.h",
    "gamma.h",
    "hyp2f1.h",
    "iv_ratio.h",
    "kelvin.h",
    "lambertw.h",
    "legendre.h",
    "log_exp.h",
    "log.h",
    "loggamma.h",
    "mathieu.h",
    "par_cyl.h",
    "sici.h",
    "specfun.h",
    "sph_bessel.h",
    "sph_harm.h",
    "sphd_wave.h",
    "stats.h",
    "struve.h",
    "trig.h",
    "wright_bessel.h",
    "zeta.h",
];
const WRAPPER_SPECS: &[(&str, &str)] = &[
    // airy.h
    ("airy", "d->dddd"),
    ("airy", "D->DDDD"),
    ("airye", "d->dddd"),
    ("airye", "D->DDDD"),
    ("itairy", "d->dddd"),
    // alg.h
    ("cbrt", "d->d"),
    // bessel.h
    ("it1j0y0", "d->dd"),
    ("it2j0y0", "d->dd"),
    ("it1i0k0", "d->dd"),
    ("it2i0k0", "d->dd"),
    ("cyl_bessel_j", "dd->d"),
    ("cyl_bessel_j", "dD->D"),
    ("cyl_bessel_je", "dd->d"),
    ("cyl_bessel_je", "dD->D"),
    ("cyl_bessel_j0", "d->d"),
    ("cyl_bessel_j1", "d->d"),
    ("cyl_bessel_y", "dd->d"),
    ("cyl_bessel_y", "dD->D"),
    ("cyl_bessel_ye", "dd->d"),
    ("cyl_bessel_ye", "dD->D"),
    ("cyl_bessel_y0", "d->d"),
    ("cyl_bessel_y1", "d->d"),
    ("cyl_bessel_i", "dd->d"),
    ("cyl_bessel_i", "dD->D"),
    ("cyl_bessel_ie", "dd->d"),
    ("cyl_bessel_ie", "dD->D"),
    ("cyl_bessel_i0", "d->d"),
    ("cyl_bessel_i0e", "d->d"),
    ("cyl_bessel_i1", "d->d"),
    ("cyl_bessel_i1e", "d->d"),
    ("cyl_bessel_k", "dd->d"),
    ("cyl_bessel_k", "dD->D"),
    ("cyl_bessel_ke", "dd->d"),
    ("cyl_bessel_ke", "dD->D"),
    ("cyl_bessel_k0", "d->d"),
    ("cyl_bessel_k0e", "d->d"),
    ("cyl_bessel_k1", "d->d"),
    ("cyl_bessel_k1e", "d->d"),
    ("cyl_hankel_1", "dD->D"),
    ("cyl_hankel_1e", "dD->D"),
    ("cyl_hankel_2", "dD->D"),
    ("cyl_hankel_2e", "dD->D"),
    ("besselpoly", "ddd->d"),
    // beta.h
    ("beta", "dd->d"),
    ("betaln", "dd->d"),
    // binom.h
    ("binom", "dd->d"),
    // cdflib.h
    ("gdtrib", "ddd->d"),
    // digamma.h
    ("digamma", "d->d"),
    ("digamma", "D->D"),
    // ellip.h
    ("ellipj", "dd->dddd"),
    ("ellipk", "d->d"),
    ("ellipkm1", "d->d"),
    ("ellipkinc", "dd->d"),
    ("ellipe", "d->d"),
    ("ellipeinc", "dd->d"),
    // erf.h
    ("erf", "d->d"),
    ("erf", "D->D"),
    ("erfc", "d->d"),
    ("erfc", "D->D"),
    ("erfcx", "d->d"),
    ("erfcx", "D->D"),
    ("erfi", "d->d"),
    ("erfi", "D->D"),
    ("voigt_profile", "ddd->d"),
    ("wofz", "D->D"),
    ("dawsn", "d->d"),
    ("dawsn", "D->D"),
    // exp.h
    ("expm1", "d->d"),
    ("expm1", "D->D"),
    ("exp2", "d->d"),
    ("exp10", "d->d"),
    // expint.h
    ("exp1", "d->d"),
    ("exp1", "D->D"),
    ("expi", "d->d"),
    ("expi", "D->D"),
    ("scaled_exp1", "d->d"),
    // fp_error_metrics.h
    ("extended_absolute_error", "dd->d"),
    ("extended_absolute_error", "DD->d"),
    ("extended_relative_error", "dd->d"),
    ("extended_relative_error", "DD->d"),
    // fresnel.h
    ("fresnel", "d->dd"),
    ("fresnel", "D->DD"),
    ("modified_fresnel_plus", "d->DD"),
    ("modified_fresnel_minus", "d->DD"),
    // gamma.h
    ("gamma", "d->d"),
    ("gamma", "D->D"),
    ("gammaln", "d->d"),
    ("gammasgn", "d->d"),
    ("gammainc", "dd->d"),
    ("gammaincinv", "dd->d"),
    ("gammaincc", "dd->d"),
    ("gammainccinv", "dd->d"),
    // hyp2f1.h
    ("hyp2f1", "dddd->d"),
    ("hyp2f1", "dddD->D"),
    // iv_ratio.h
    ("iv_ratio", "dd->d"),
    ("iv_ratio_c", "dd->d"),
    // kelvin.h
    ("ber", "d->d"),
    ("bei", "d->d"),
    ("ker", "d->d"),
    ("kei", "d->d"),
    ("berp", "d->d"),
    ("beip", "d->d"),
    ("kerp", "d->d"),
    ("keip", "d->d"),
    ("kelvin", "d->DDDD"),
    // lambertw.h
    ("lambertw", "Dld->D"),
    // legendre.h
    ("legendre_p", "id->d"),
    ("legendre_p", "iD->D"),
    ("sph_legendre_p", "iid->d"),
    ("sph_legendre_p", "iiD->D"),
    // log_exp.h
    ("expit", "d->d"),
    ("exprel", "d->d"),
    ("logit", "d->d"),
    ("log_expit", "d->d"),
    ("log1mexp", "d->d"),
    // log.h
    ("log1p", "d->d"),
    ("log1p", "D->D"),
    ("log1pmx", "d->d"),
    ("xlogy", "dd->d"),
    ("xlogy", "DD->D"),
    ("xlog1py", "dd->d"),
    ("xlog1py", "DD->D"),
    // loggamma.h
    ("loggamma", "d->d"),
    ("loggamma", "D->D"),
    ("rgamma", "d->d"),
    ("rgamma", "D->D"),
    // mathieu.h
    ("cem_cva", "dd->d"),
    ("sem_cva", "dd->d"),
    ("cem", "ddd->dd"),
    ("sem", "ddd->dd"),
    ("mcm1", "ddd->dd"),
    ("msm1", "ddd->dd"),
    ("mcm2", "ddd->dd"),
    ("msm2", "ddd->dd"),
    // par_cyl.h
    ("pbwa", "dd->dd"),
    ("pbdv", "dd->dd"),
    ("pbvv", "dd->dd"),
    // sici.h
    ("sici", "d->dd"),
    ("sici", "D->DD"),
    ("shichi", "d->dd"),
    ("shichi", "D->DD"),
    // specfun.h
    ("hyp1f1", "ddd->d"),
    ("hyp1f1", "ddD->D"),
    ("hypu", "ddd->d"),
    ("pmv", "ddd->d"),
    // sph_bessel.h
    ("sph_bessel_j", "ld->d"),
    ("sph_bessel_j", "lD->D"),
    ("sph_bessel_j_jac", "ld->d"),
    ("sph_bessel_j_jac", "lD->D"),
    ("sph_bessel_y", "ld->d"),
    ("sph_bessel_y", "lD->D"),
    ("sph_bessel_y_jac", "ld->d"),
    ("sph_bessel_y_jac", "lD->D"),
    ("sph_bessel_i", "ld->d"),
    ("sph_bessel_i", "lD->D"),
    ("sph_bessel_i_jac", "ld->d"),
    ("sph_bessel_i_jac", "lD->D"),
    ("sph_bessel_k", "ld->d"),
    ("sph_bessel_k", "lD->D"),
    ("sph_bessel_k_jac", "ld->d"),
    ("sph_bessel_k_jac", "lD->D"),
    // sph_harm.h
    ("sph_harm_y", "iidd->D"),
    // sphd_wave.h
    ("prolate_segv", "ddd->d"),
    ("prolate_aswfa_nocv", "dddd->dd"),
    ("prolate_radial1_nocv", "dddd->dd"),
    ("prolate_radial2_nocv", "dddd->dd"),
    ("prolate_aswfa", "ddddd->dd"),
    ("prolate_radial1", "ddddd->dd"),
    ("prolate_radial2", "ddddd->dd"),
    ("oblate_segv", "ddd->d"),
    ("oblate_aswfa_nocv", "dddd->dd"),
    ("oblate_radial1_nocv", "dddd->dd"),
    ("oblate_radial2_nocv", "dddd->dd"),
    ("oblate_radial1", "ddddd->dd"),
    ("oblate_radial2", "ddddd->dd"),
    ("oblate_aswfa", "ddddd->dd"),
    // stats.h
    ("bdtr", "did->d"),
    ("bdtrc", "did->d"),
    ("bdtri", "did->d"),
    ("chdtr", "dd->d"),
    ("chdtrc", "dd->d"),
    ("chdtri", "dd->d"),
    ("fdtr", "ddd->d"),
    ("fdtrc", "ddd->d"),
    ("fdtri", "ddd->d"),
    ("gdtr", "ddd->d"),
    ("gdtrc", "ddd->d"),
    ("kolmogorov", "d->d"),
    ("kolmogc", "d->d"),
    ("kolmogi", "d->d"),
    ("kolmogci", "d->d"),
    ("kolmogp", "d->d"),
    ("ndtr", "d->d"),
    ("ndtr", "D->D"),
    ("ndtri", "d->d"),
    ("log_ndtr", "d->d"),
    ("log_ndtr", "D->D"),
    ("nbdtr", "iid->d"),
    ("nbdtrc", "iid->d"),
    ("nbdtri", "iid->d"),
    ("owens_t", "dd->d"),
    ("pdtr", "dd->d"),
    ("pdtrc", "dd->d"),
    ("pdtri", "id->d"),
    ("smirnov", "id->d"),
    ("smirnovc", "id->d"),
    ("smirnovci", "id->d"),
    ("smirnovi", "id->d"),
    ("smirnovp", "id->d"),
    ("tukeylambdacdf", "dd->d"),
    // struve.h
    ("itstruve0", "d->d"),
    ("it2struve0", "d->d"),
    ("itmodstruve0", "d->d"),
    ("struve_h", "dd->d"),
    ("struve_l", "dd->d"),
    // trig.h
    ("sinpi", "d->d"),
    ("sinpi", "D->D"),
    ("cospi", "d->d"),
    ("cospi", "D->D"),
    ("sindg", "d->d"),
    ("cosdg", "d->d"),
    ("tandg", "d->d"),
    ("cotdg", "d->d"),
    ("cosm1", "d->d"),
    ("radian", "ddd->d"),
    // wright_bessel.h
    ("wright_bessel", "ddd->d"),
    ("log_wright_bessel", "ddd->d"),
    // zeta.h
    ("riemann_zeta", "d->d"),
    ("riemann_zeta", "D->D"),
    ("zetac", "d->d"),
    ("zeta", "dd->d"),
    ("zeta", "Dd->D"),
];

const _CPP_COMPLEX_HELPERS: &str = r#"
// C-ABI compatible complex type (same layout as std::complex<double>)
// Hide the struct definition from bindgen - we'll provide our own type alias in Rust
#ifndef BINDGEN
struct c_complex {
    double re;
    double im;
};
#else
// For bindgen, just declare it as an opaque struct
struct c_complex;
#endif

// Helper functions to convert between C-compatible and C++ complex types
#ifndef BINDGEN
inline c_complex to_c_complex(std::complex<double> z) { return c_complex{z.real(), z.imag()}; }
inline std::complex<double> to_cpp_complex(c_complex z) { return std::complex<double>(z.re, z.im); }
#endif
"#;

const _CPP_WRAPPERS: &str = r#"
// cephes/erfinv.h
double erfinv(double y) {
    return xsf::cephes::erfinv(y);
}
double erfcinv(double y) {
    return xsf::cephes::erfcinv(y);
}

// cephes/expn.h
double expn(int n, double x) {
    return xsf::cephes::expn(n, x);
}

// cephes/incbet.h
double incbet(double a, double b, double x) {
    return xsf::cephes::incbet(a, b, x);
}

// cephes/incbi.h
double incbi(double a, double b, double y) {
    return xsf::cephes::incbi(a, b, y);
}

// cephes/lanczos.h
double lanczos_sum_expg_scaled(double x) {
    return xsf::cephes::lanczos_sum_expg_scaled(x);
}

// cephes/poch.h
double poch(double a, double m) {
    return xsf::cephes::poch(a, m);
}

// cephes/round.h
double round(double x) {
    return xsf::cephes::round(x);
}

// cephes/spence.h
double spence(double x) {
    return xsf::cephes::spence(x);
}

// cephes/unity.h
double lgam1p(double x) {
    return xsf::cephes::lgam1p(x);
}

// specfun/specfun.h
void bernob(int n, double *bn) {
    xsf::specfun::bernob(n, bn);
}
void cerzo(int nt, c_complex *zo) {
    std::vector<std::complex<double>> czo(nt);
    xsf::specfun::cerzo(nt, czo.data());
    for (int i = 0; i < nt; i++) {
        zo[i] = to_c_complex(czo[i]);
    }
}
void eulerb(int n, double *en) {
    xsf::specfun::eulerb(n, en);
}
void jyzo(int n, int nt, double *rj0, double *rj1, double *ry0, double *ry1) {
    xsf::specfun::jyzo(n, nt, rj0, rj1, ry0, ry1);
}
int lamn(int n, double x, double *bl, double *dl) {
    int nm = -1;
    xsf::specfun::lamn(n, x, &nm, bl, dl);
    return nm;
}
double lamv(double v, double x, double *vl, double *dl) {
    double vm = -1.0;
    xsf::specfun::lamv(v, x, &vm, vl, dl);
    return vm;
}

// airy.h
void airyzo(size_t nt, int kf, double *xa, double *xb, double *xc, double *xd) {
    std::vector<double> ya(nt), yb(nt), yc(nt), yd(nt);
    xsf::airyzo(static_cast<int>(nt), kf, ya.data(), yb.data(), yc.data(), yd.data());
    for (size_t i = 0; i < nt; i++) {
        xa[i] = ya[i];
        xb[i] = yb[i];
        xc[i] = yc[i];
        xd[i] = yd[i];
    }
}

// bessel.h
int rctj(size_t nt, double x, double *rj, double *dj) {
    int nm;
    xsf::rctj(x, &nm, std::mdspan(rj, nt), std::mdspan(dj, nt));
    return nm;
}
int rcty(size_t nt, double x, double *ry, double *dy) {
    int nm;
    xsf::rcty(x, &nm, std::mdspan(ry, nt), std::mdspan(dy, nt));
    return nm;
}

// evalpoly.h
c_complex cevalpoly(const double *coeffs, int degree, c_complex z) {
    return to_c_complex(xsf::cevalpoly(coeffs, degree, to_cpp_complex(z)));
}

// fresnel.h
void fcszo(int kf, int nt, c_complex *zo) {
    std::vector<std::complex<double>> czo(nt);
    xsf::fcszo(kf, nt, czo.data());
    for (int i = 0; i < nt; i++) {
        zo[i] = to_c_complex(czo[i]);
    }
}

// kelvin.h
void klvnzo(int nt, int kd, double *zo) {
    xsf::klvnzo(nt, kd, zo);
}

// legendre.h
double assoc_legendre_p_0(int n, int m, double z, int bc) {
    return xsf::assoc_legendre_p(xsf::assoc_legendre_unnorm, n, m, z, bc);
}
double assoc_legendre_p_1(int n, int m, double z, int bc) {
    return xsf::assoc_legendre_p(xsf::assoc_legendre_norm, n, m, z, bc);
}
c_complex assoc_legendre_p_0_1(int n, int m, c_complex z, int bc) {
    return to_c_complex(xsf::assoc_legendre_p(xsf::assoc_legendre_unnorm, n, m, to_cpp_complex(z), bc));
}
c_complex assoc_legendre_p_1_1(int n, int m, c_complex z, int bc) {
    return to_c_complex(xsf::assoc_legendre_p(xsf::assoc_legendre_norm, n, m, to_cpp_complex(z), bc));
}
void legendre_p_all(size_t n, double x, double *pn) {
    xsf::legendre_p_all(x, std::mdspan(pn, n + 1));
}
void legendre_p_all_1(size_t n, c_complex z, c_complex *pn) {
    std::vector<std::complex<double>> cpn(n + 1);
    xsf::legendre_p_all(to_cpp_complex(z), std::mdspan(cpn.data(), n + 1));
    for (size_t i = 0; i <= n; i++) {
        pn[i] = to_c_complex(cpn[i]);
    }
}
void sph_legendre_p_all(size_t n, size_t m, double x, double *pnm) {
    xsf::sph_legendre_p_all(x, std::mdspan(pnm, n + 1, 2 * m + 1));
}
void sph_legendre_p_all_1(size_t n, size_t m, c_complex z, c_complex *pnm) {
    std::vector<std::complex<double>> cpnm((n + 1) * (2 * m + 1));
    xsf::sph_legendre_p_all(to_cpp_complex(z), std::mdspan(cpnm.data(), n + 1, 2 * m + 1));
    for (size_t i = 0; i < (n + 1) * (2 * m + 1); i++) {
        pnm[i] = to_c_complex(cpnm[i]);
    }
}
void assoc_legendre_p_all_0(size_t n, size_t m, double z, int bc, double *pnm) {
    auto res = std::mdspan(pnm, n + 1, 2 * m + 1);
    xsf::assoc_legendre_p_all(xsf::assoc_legendre_unnorm, z, bc, res);
}
void assoc_legendre_p_all_0_1(size_t n, size_t m, c_complex z, int bc, c_complex *pnm) {
    std::vector<std::complex<double>> cpnm((n + 1) * (2 * m + 1));
    auto res = std::mdspan(cpnm.data(), n + 1, 2 * m + 1);
    xsf::assoc_legendre_p_all(xsf::assoc_legendre_unnorm, to_cpp_complex(z), bc, res);
    for (size_t i = 0; i < (n + 1) * (2 * m + 1); i++) {
        pnm[i] = to_c_complex(cpnm[i]);
    }
}
void assoc_legendre_p_all_1(size_t n, size_t m, double z, int bc, double *pnm) {
    auto res = std::mdspan(pnm, n + 1, 2 * m + 1);
    xsf::assoc_legendre_p_all(xsf::assoc_legendre_norm, z, bc, res);
}
void assoc_legendre_p_all_1_1(size_t n, size_t m, c_complex z, int bc, c_complex *pnm) {
    std::vector<std::complex<double>> cpnm((n + 1) * (2 * m + 1));
    auto res = std::mdspan(cpnm.data(), n + 1, 2 * m + 1);
    xsf::assoc_legendre_p_all(xsf::assoc_legendre_norm, to_cpp_complex(z), bc, res);
    for (size_t i = 0; i < (n + 1) * (2 * m + 1); i++) {
        pnm[i] = to_c_complex(cpnm[i]);
    }
}

// legendre.h
void lqn(size_t n, double x, double *qn, double *qd) {
    xsf::lqn(x, std::mdspan(qn, n + 1), std::mdspan(qd, n + 1));
}
void lqn_1(size_t n, c_complex z, c_complex *qn, c_complex *qd) {
    std::vector<std::complex<double>> cqn(n + 1);
    std::vector<std::complex<double>> cqd(n + 1);
    xsf::lqn(to_cpp_complex(z), std::mdspan(cqn.data(), n + 1), std::mdspan(cqd.data(), n + 1));
    for (size_t i = 0; i <= n; i++) {
        qn[i] = to_c_complex(cqn[i]);
        qd[i] = to_c_complex(cqd[i]);
    }
}
void lqmn(size_t m, size_t n, double x, double *qm, double *qd) {
    xsf::lqmn(x, std::mdspan(qm, m + 1, n + 1), std::mdspan(qd, m + 1, n + 1));
}
void lqmn_1(size_t m, size_t n, c_complex z, c_complex *qm, c_complex *qd) {
    std::vector<std::complex<double>> cqm((m + 1) * (n + 1));
    std::vector<std::complex<double>> cqd((m + 1) * (n + 1));
    xsf::lqmn(to_cpp_complex(z), std::mdspan(cqm.data(), m + 1, n + 1), std::mdspan(cqd.data(), m + 1, n + 1));
    for (size_t i = 0; i < (m + 1) * (n + 1); i++) {
        qm[i] = to_c_complex(cqm[i]);
        qd[i] = to_c_complex(cqd[i]);
    }
}

// sph_harm.h
void sph_harm_y_all(size_t n, size_t m, double theta, double phi, c_complex *res) {
    std::vector<std::complex<double>> cres((n + 1) * (2 * m + 1));
    xsf::sph_harm_y_all(theta, phi, std::mdspan(cres.data(), n + 1, 2 * m + 1));
    for (size_t i = 0; i < (n + 1) * (2 * m + 1); i++) {
        res[i] = to_c_complex(cres[i]);
    }
}
"#;

fn cpp_function_names(cpp: &str) -> impl Iterator<Item = &str> {
    cpp.lines().filter_map(|line| {
        let trimmed = line.trim_start();
        if trimmed.contains('(') && line.ends_with(r") {") {
            trimmed
                .split('(')
                .next()
                .and_then(|part| part.split_whitespace().last())
        } else {
            None
        }
    })
}

fn cpp_to_hpp(cpp: &str) -> String {
    cpp.lines()
        .map(|line| line.trim_end())
        .filter_map(|line| {
            if !line.starts_with(' ') && line.ends_with(r") {") && line.contains('(') {
                Some(format!("{};", &line[..line.len() - 2].trim_end()))
            } else {
                None
            }
        })
        .collect::<Vec<_>>()
        .join("\n")
}

fn get_ctype(code: char) -> &'static str {
    match code {
        'i' => "int",
        'l' => "long",
        'd' => "double",
        'D' => "c_complex",
        'V' => "void",
        _ => panic!("Unknown parameter type"),
    }
}

fn split_typespec(spec: &str) -> (&str, &str) {
    let parts: Vec<&str> = spec.split("->").collect();
    assert!(parts.len() == 2);
    (parts[0], parts[1])
}

fn fmt_return(spec: &str) -> &str {
    let chars = split_typespec(spec).1;
    if chars.len() > 1 {
        "void"
    } else {
        get_ctype(chars.chars().next().unwrap())
    }
}

fn fmt_params(spec: &str, types: bool) -> String {
    let (inputs, outputs) = split_typespec(spec);

    let mut params = inputs
        .chars()
        .map(get_ctype)
        .enumerate()
        .map(|(i, ct)| {
            if types {
                format!("{ct} x{i}")
            } else {
                format!("x{i}")
            }
        })
        .collect::<Vec<_>>();

    if outputs.len() > 1 {
        if types {
            params.extend(
                outputs
                    .chars()
                    .map(get_ctype)
                    .enumerate()
                    .map(|(i, ct)| format!("{ct} &y{i}")),
            );
        } else {
            params.extend((0..outputs.len()).map(|i| format!("y{i}")));
        }
    }

    params.join(", ")
}

fn fmt_func(name: &str, spec: &str, suffix: &str) -> String {
    let rtype = fmt_return(spec);
    let params = fmt_params(spec, true);

    let fname = if suffix.is_empty() {
        name.to_string()
    } else {
        format!("{name}_{suffix}")
    };
    format!("{rtype} {fname}({params})")
}

fn fmt_call(name: &str, spec: &str) -> Vec<String> {
    let (inputs, outputs) = split_typespec(spec);

    let mut args = inputs
        .chars()
        .enumerate()
        .map(|(i, c)| {
            if c == 'D' {
                format!("to_cpp_complex(x{i})")
            } else {
                format!("x{i}")
            }
        })
        .collect::<Vec<String>>();

    if outputs.len() > 1 {
        args.extend(outputs.chars().enumerate().map(|(i, c)| {
            if c == 'D' {
                format!("cy{i}")
            } else {
                format!("y{i}")
            }
        }));
    }

    let call_args = args.join(", ");
    let call_stmt = format!("xsf::{name}({call_args})");

    if outputs.len() == 1 {
        if outputs == "D" {
            vec![format!("return to_c_complex({call_stmt})")]
        } else {
            vec![format!("return {call_stmt}")]
        }
    } else {
        let mut stmts = vec![];

        let cys = outputs
            .chars()
            .enumerate()
            .filter_map(|(i, c)| {
                if c == 'D' {
                    Some(format!("cy{i}"))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        if !cys.is_empty() {
            stmts.push(format!("std::complex<double> {cys}"));
        }

        stmts.push(call_stmt);

        for (i, c) in outputs.chars().enumerate() {
            if c == 'D' {
                stmts.push(format!("y{i} = to_c_complex(cy{i})"));
            }
        }
        stmts
    }
}

fn push_line(source: &mut String, line: &str) {
    source.push_str(line.trim_end());
    source.push('\n');
}

fn write_file(path: String, content: String) -> String {
    fs::write(&path, content).unwrap();
    path
}

fn generate_hpp(dir_out: &str) -> String {
    let mut source = String::from(WRAPPER_PREAMBLE);

    // includes
    push_line(&mut source, "#include <complex>");
    push_line(&mut source, "#include <vector>");
    push_line(&mut source, "");

    // namespace
    push_line(&mut source, &format!("namespace {WRAPPER_NAME} {{"));

    // complex helpers
    push_line(&mut source, _CPP_COMPLEX_HELPERS);

    // simple wrappers
    let mut name_counts = HashMap::new();
    for (name, types) in WRAPPER_SPECS {
        let count = name_counts.entry(*name).or_insert(0);
        let suffix = if *count == 0 { "" } else { &count.to_string() };
        let func_decl = fmt_func(name, types, suffix);
        push_line(&mut source, &format!("{func_decl};"));
        *count += 1;
    }

    // additional wrappers
    push_line(&mut source, &cpp_to_hpp(_CPP_WRAPPERS));

    // close namespace
    push_line(&mut source, "}");

    // write to file
    write_file(format!("{dir_out}/{WRAPPER_NAME}.hpp"), source)
}

fn generate_cpp(dir_out: &str) -> String {
    let mut source = String::from(WRAPPER_PREAMBLE);

    // C++23 `std::mdspan` backport
    push_line(&mut source, "#define MDSPAN_USE_PAREN_OPERATOR 1");
    push_line(
        &mut source,
        r#"#include "xsf/third_party/kokkos/mdspan.hpp""#,
    );
    push_line(&mut source, "");

    // includes
    push_line(&mut source, &format!(r#"#include "{WRAPPER_NAME}.hpp""#));
    for xsf_header in WRAPPER_INCLUDES {
        push_line(&mut source, &format!(r#"#include "xsf/{xsf_header}""#));
    }
    push_line(&mut source, "");

    // namespace
    push_line(&mut source, &format!("namespace {WRAPPER_NAME} {{"));
    push_line(&mut source, "");

    // simple wrappers
    let mut name_counts = HashMap::new();
    for (name, types) in WRAPPER_SPECS {
        let count = name_counts.entry(*name).or_insert(0);
        let suffix = if *count == 0 { "" } else { &count.to_string() };
        *count += 1;

        let decl = fmt_func(name, types, suffix);
        let call_stmts = fmt_call(name, types);
        assert!(!call_stmts.is_empty());

        push_line(&mut source, &format!("{decl} {{"));
        for stmt in call_stmts {
            push_line(&mut source, &format!("    {stmt};"));
        }
        push_line(&mut source, "}");
    }

    // additional wrappers
    push_line(&mut source, _CPP_WRAPPERS);

    // close namespace
    push_line(&mut source, "");
    push_line(&mut source, "}");

    // write to file
    write_file(format!("{dir_out}/{WRAPPER_NAME}.cpp"), source)
}

fn build_wrapper(dir_out: &str) {
    let file_cpp = generate_cpp(dir_out);

    let mut build = cc::Build::new();
    build
        .cpp(true)
        .flag_if_supported("-Wno-unused-parameter")
        .flag_if_supported("-Wno-logical-op-parentheses")
        .include(XSF_INCLUDE)
        .file(file_cpp);

    if build.get_compiler().is_like_msvc() {
        build.flag(format!("/std:{CXX_STANDARD}"));
    } else {
        build.std(CXX_STANDARD);
    }

    build.compile(WRAPPER_NAME)
}

fn get_allowlist() -> String {
    format!(
        "{}::({})",
        WRAPPER_NAME,
        WRAPPER_SPECS
            .iter()
            .map(|(name, _)| format!(r"{name}(_\d)?"))
            .chain(cpp_function_names(_CPP_WRAPPERS).map(String::from))
            .collect::<Vec<_>>()
            .join("|")
    )
}

fn generate_bindings(dir_out: &str, header: &str) {
    bindgen::Builder::default()
        .header(header)
        .allowlist_function(get_allowlist())
        .blocklist_type("xsf_wrapper::c_complex")
        .clang_args(["-x", "c++", "-DBINDGEN"])
        .enable_cxx_namespaces()
        .sort_semantically(true)
        .merge_extern_blocks(true)
        .use_core()
        .module_raw_line(
            "root::xsf_wrapper",
            "pub type c_complex = num_complex::Complex<f64>;",
        )
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .generate()
        .unwrap()
        .write_to_file(PathBuf::from(dir_out).join("bindings.rs"))
        .unwrap();
}

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let header = generate_hpp(&out_dir);

    println!("cargo:rerun-if-changed={XSF_INCLUDE}");

    build_wrapper(&out_dir);
    generate_bindings(&out_dir, &header);
}
