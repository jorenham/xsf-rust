use core::panic;
use std::env;
use std::path::PathBuf;

const WRAPPER_NAME: &str = "xsf_wrapper";
const WRAPPER_PREAMBLE: &str = "// generated by build.rs -- do not edit\n\n";

const XSF_HEADERS: &[&str] = &[
    // "airy.h",
    "alg.h",
    "bessel.h",
    "beta.h",
    "binom.h",
    "cdflib.h",
    "digamma.h",
    "ellip.h",
    "erf.h",
    // "evalpoly.h"
    "exp.h",
    "expint.h",
    // "fp_error_metrics.h",
    // "fresnel.h",
    "gamma.h",
    "hyp2f1.h",
    "iv_ratio.h",
    "kelvin.h",
    "lambertw.h",
    "legendre.h",
    "log_exp.h",
    "log.h",
    "loggamma.h",
    "mathieu.h",
    // "par_cyl.h",
    // "sici.h",
    "specfun.h",
    "sph_bessel.h",
    "sph_harm.h",
    "sphd_wave.h",
    "stats.h",
    "struve.h",
    "trig.h",
    "wright_bessel.h",
    "zeta.h",
];
// e.g. `("spam", "if->d")` becomes `double xsf_spam(int x0, float x1)`
const XSF_TYPES: &[(&str, &str)] = &[
    // airy.h
    //  TODO: `airyb`, `airyzo`, `airy`, `airye`, `itairy`
    ("cbrt", "d->d"),
    // bessel.h
    //  TODO: `it1j0y0`, `it2j0y0`, `it1i0k0`, `it2i0k0`
    //  TODO: `rctj`, `rcty`,
    ("cyl_bessel_j", "dd->d"),
    ("cyl_bessel_j", "dD->D"),
    ("cyl_bessel_je", "dd->d"),
    ("cyl_bessel_je", "dD->D"),
    ("cyl_bessel_j0", "d->d"),
    ("cyl_bessel_j1", "d->d"),
    ("cyl_bessel_y", "dd->d"),
    ("cyl_bessel_y", "dD->D"),
    ("cyl_bessel_ye", "dd->d"),
    ("cyl_bessel_ye", "dD->D"),
    ("cyl_bessel_y0", "d->d"),
    ("cyl_bessel_y1", "d->d"),
    ("cyl_bessel_i", "dd->d"),
    ("cyl_bessel_i", "dD->D"),
    ("cyl_bessel_ie", "dd->d"),
    ("cyl_bessel_ie", "dD->D"),
    ("cyl_bessel_i0", "d->d"),
    ("cyl_bessel_i0e", "d->d"),
    ("cyl_bessel_i1", "d->d"),
    ("cyl_bessel_i1e", "d->d"),
    ("cyl_bessel_k", "dd->d"),
    ("cyl_bessel_k", "dD->D"),
    ("cyl_bessel_ke", "dd->d"),
    ("cyl_bessel_ke", "dD->D"),
    ("cyl_bessel_k0", "d->d"),
    ("cyl_bessel_k0e", "d->d"),
    ("cyl_bessel_k1", "d->d"),
    ("cyl_bessel_k1e", "d->d"),
    ("cyl_hankel_1", "dD->D"),
    ("cyl_hankel_1e", "dD->D"),
    ("cyl_hankel_2", "dD->D"),
    ("cyl_hankel_2e", "dD->D"),
    ("besselpoly", "ddd->d"),
    // beta.h
    ("beta", "dd->d"),
    ("betaln", "dd->d"),
    // binom.h
    ("binom", "dd->d"),
    // cdflib.h
    ("gdtrib", "ddd->d"),
    // digamma.h
    ("digamma", "d->d"),
    ("digamma", "D->D"),
    // ellip.h
    //  TODO: ellipj
    ("ellipk", "d->d"),
    ("ellipkm1", "d->d"),
    ("ellipkinc", "dd->d"),
    ("ellipe", "d->d"),
    ("ellipeinc", "dd->d"),
    // erf.h
    ("erf", "d->d"),
    ("erf", "D->D"),
    ("erfc", "d->d"),
    ("erfc", "D->D"),
    ("erfcx", "d->d"),
    ("erfcx", "D->D"),
    ("erfi", "d->d"),
    ("erfi", "D->D"),
    ("voigt_profile", "ddd->d"),
    ("wofz", "D->D"),
    ("dawsn", "d->d"),
    ("dawsn", "D->D"),
    // evalpoly.h
    //  TODO: `cevalpoly`
    // exp.h
    ("expm1", "d->d"),
    ("expm1", "D->D"),
    ("exp2", "d->d"),
    ("exp10", "d->d"),
    // expint.h
    ("exp1", "d->d"),
    ("exp1", "D->D"),
    ("expi", "d->d"),
    ("expi", "D->D"),
    ("scaled_exp1", "d->d"),
    // fresnel.h
    //  TODO: `fresnel`, `fcszo`
    // gamma.h
    ("gamma", "d->d"),
    ("gamma", "D->D"),
    ("gammaln", "d->d"),
    ("gammasgn", "d->d"),
    ("gammainc", "dd->d"),
    ("gammaincinv", "dd->d"),
    ("gammaincc", "dd->d"),
    ("gammainccinv", "dd->d"),
    // hyp2f1.h
    ("hyp2f1", "dddd->d"),
    ("hyp2f1", "dddD->D"),
    // iv_ratio.h
    ("iv_ratio", "dd->d"),
    ("iv_ratio_c", "dd->d"),
    // kelvin.h
    //  TODO: `kelvin`, `klvnzo`
    ("ber", "d->d"),
    ("bei", "d->d"),
    ("ker", "d->d"),
    ("kei", "d->d"),
    ("berp", "d->d"),
    ("beip", "d->d"),
    ("kerp", "d->d"),
    ("keip", "d->d"),
    // lambertw.h
    ("lambertw", "Dld->D"),
    // legendre.h
    ("legendre_p", "id->d"),
    ("legendre_p", "iD->D"),
    ("sph_legendre_p", "iid->d"),
    ("sph_legendre_p", "iiD->D"),
    // log_exp.h
    ("expit", "d->d"),
    ("exprel", "d->d"),
    ("logit", "d->d"),
    ("log_expit", "d->d"),
    ("log1mexp", "d->d"),
    // log.h
    ("log1p", "d->d"),
    ("log1p", "D->D"),
    ("log1pmx", "d->d"),
    ("xlogy", "dd->d"),
    ("xlogy", "DD->D"),
    ("xlog1py", "dd->d"),
    ("xlog1py", "DD->D"),
    // loggamma.h
    ("loggamma", "d->d"),
    ("loggamma", "D->D"),
    ("rgamma", "d->d"),
    ("rgamma", "D->D"),
    // mathieu.h
    //  TODO: `cen`, `sem`, `mcm1`, `msm1`, `mcm2`, `msm2`
    ("cem_cva", "dd->d"),
    ("sem_cva", "dd->d"),
    // par_cyl.h
    //  TODO: `pbwa`, `pbdv`, `pbvv`
    // sici.h
    //  TODO: `sici`, `shichi`,
    // specfun.h
    ("hyp1f1", "ddd->d"),
    ("hyp1f1", "ddD->D"),
    ("hypu", "ddd->d"),
    ("pmv", "ddd->d"),
    // sph_bessel.h
    ("sph_bessel_j", "ld->d"),
    ("sph_bessel_j", "lD->D"),
    ("sph_bessel_j_jac", "ld->d"),
    ("sph_bessel_j_jac", "lD->D"),
    ("sph_bessel_y", "ld->d"),
    ("sph_bessel_y", "lD->D"),
    ("sph_bessel_y_jac", "ld->d"),
    ("sph_bessel_y_jac", "lD->D"),
    ("sph_bessel_i", "ld->d"),
    ("sph_bessel_i", "lD->D"),
    ("sph_bessel_i_jac", "ld->d"),
    ("sph_bessel_i_jac", "lD->D"),
    ("sph_bessel_k", "ld->d"),
    ("sph_bessel_k", "lD->D"),
    ("sph_bessel_k_jac", "ld->d"),
    ("sph_bessel_k_jac", "lD->D"),
    // sph_harm.h
    ("sph_harm_y", "iidd->D"),
    // sphd_wave.h
    //  TODO: aswfa and radial
    ("prolate_segv", "ddd->d"),
    ("oblate_segv", "ddd->d"),
    // stats.h
    ("bdtr", "did->d"),
    ("bdtrc", "did->d"),
    ("bdtri", "did->d"),
    ("chdtr", "dd->d"),
    ("chdtrc", "dd->d"),
    ("chdtri", "dd->d"),
    ("fdtr", "ddd->d"),
    ("fdtrc", "ddd->d"),
    ("fdtri", "ddd->d"),
    ("gdtr", "ddd->d"),
    ("gdtrc", "ddd->d"),
    ("kolmogorov", "d->d"),
    ("kolmogc", "d->d"),
    ("kolmogi", "d->d"),
    ("kolmogci", "d->d"),
    ("kolmogp", "d->d"),
    ("ndtr", "d->d"),
    ("ndtr", "D->D"),
    ("ndtri", "d->d"),
    ("log_ndtr", "d->d"),
    ("log_ndtr", "D->D"),
    ("nbdtr", "iid->d"),
    ("nbdtrc", "iid->d"),
    ("nbdtri", "iid->d"),
    ("owens_t", "dd->d"),
    ("pdtr", "dd->d"),
    ("pdtrc", "dd->d"),
    ("pdtri", "id->d"),
    ("smirnov", "id->d"),
    ("smirnovc", "id->d"),
    ("smirnovci", "id->d"),
    ("smirnovi", "id->d"),
    ("smirnovp", "id->d"),
    ("tukeylambdacdf", "dd->d"),
    // struve.h
    ("itstruve0", "d->d"),
    ("it2struve0", "d->d"),
    ("itmodstruve0", "d->d"),
    ("struve_h", "dd->d"),
    ("struve_l", "dd->d"),
    // trig.h
    ("sinpi", "d->d"),
    ("sinpi", "D->D"),
    ("cospi", "d->d"),
    ("cospi", "D->D"),
    ("sindg", "d->d"),
    ("cosdg", "d->d"),
    ("tandg", "d->d"),
    ("cotdg", "d->d"),
    ("cosm1", "d->d"),
    ("radian", "ddd->d"),
    // wright_bessel.h
    ("wright_bessel", "ddd->d"),
    ("log_wright_bessel", "ddd->d"),
    // zeta.h
    ("riemann_zeta", "d->d"),
    ("riemann_zeta", "D->D"),
    ("zetac", "d->d"),
    ("zeta", "dd->d"),
    ("zeta", "Dd->D"),
];
// Functions that need renaming because they clash with standard library names
const XSF_RENAME: &[(&str, &str)] = &[
    ("cbrt", "cbrt_"),
    ("gamma", "gamma_"),
    ("erf", "erf_"),
    ("erfc", "erfc_"),
    ("expm1", "expm1_"),
    ("exp2", "exp2_"),
    ("exp10", "exp10_"),
    ("log1p", "log1p_"),
];

fn get_ctype(code: char) -> &'static str {
    match code {
        'i' => "int",
        'l' => "long",
        'f' => "float",
        'd' => "double",
        'F' => "std::complex<float>",
        'D' => "std::complex<double>",
        'V' => "void",
        _ => panic!("Unknown parameter type"),
    }
}

fn fmt_params(spec: &str, types: bool) -> String {
    // TODO: >1 outputs, e.g. `ii->di` => `void _(int x0, int x1, double &y0, int &y1)`
    spec.split("->")
        .next()
        .unwrap()
        .chars()
        .enumerate()
        .map(if types {
            |(i, p)| format!("{} x{}", get_ctype(p), i)
        } else {
            |(i, _)| format!("x{}", i)
        })
        .collect::<Vec<_>>()
        .join(", ")
}

fn fmt_return(types: &str) -> String {
    let chars = types.split("->").last().unwrap();
    assert!(chars.len() == 1, "Multiple return values not supported");
    get_ctype(chars.chars().next().unwrap()).to_string()
}

fn fmt_func(name: &str, types: &str, suffix: &str) -> String {
    let ret = fmt_return(types);
    let params = fmt_params(types, true);
    let base_name = XSF_RENAME
        .iter()
        .find(|(n, _)| *n == name)
        .map(|(_, r)| *r)
        .unwrap_or(name);
    let func_name = if suffix.is_empty() {
        base_name.to_string()
    } else {
        format!("{}_{}", base_name, suffix)
    };
    format!("{} {}({})", ret, func_name, params)
}

fn fmt_call(name: &str, types: &str) -> String {
    let args = fmt_params(types, false);
    format!("xsf::{}({})", name, args)
}

fn push_line(source: &mut String, line: &str) {
    source.push_str(line);
    source.push('\n');
}

fn generate_header(dir_out: &str) -> String {
    let mut source = String::from(WRAPPER_PREAMBLE);

    push_line(&mut source, "#pragma once");
    push_line(&mut source, "#include <complex>");

    // Put wrapper functions in their own namespace
    push_line(&mut source, "");
    push_line(&mut source, "namespace xsf_wrapper {");
    push_line(&mut source, "");
    push_line(
        &mut source,
        "std::complex<double> complex__new(double re, double im);",
    );
    push_line(&mut source, "double complex__re(std::complex<double> z);");
    push_line(&mut source, "double complex__im(std::complex<double> z);");
    push_line(&mut source, "");

    // Generate unique function names for overloads
    let mut name_counts = std::collections::HashMap::new();
    for (name, types) in XSF_TYPES {
        let count = name_counts.entry(*name).or_insert(0);
        let suffix = if *count == 0 { "" } else { &count.to_string() };
        let func_decl = fmt_func(name, types, suffix);
        push_line(&mut source, &format!("{func_decl};"));
        *count += 1;
    }

    // `assoc_legendre_p` requires special-casing
    push_line(
        &mut source,
        "double assoc_legendre_p_0(int n, int m, double z, int bc);",
    );
    push_line(
        &mut source,
        "std::complex<double> assoc_legendre_p_0_1(int n, int m, std::complex<double> z, int bc);",
    );
    push_line(
        &mut source,
        "double assoc_legendre_p_1(int n, int m, double z, int bc);",
    );
    push_line(
        &mut source,
        "std::complex<double> assoc_legendre_p_1_1(int n, int m, std::complex<double> z, int bc);",
    );

    push_line(&mut source, "");
    push_line(&mut source, "} // namespace xsf_wrapper");

    let file = format!("{dir_out}/{WRAPPER_NAME}.hpp");
    std::fs::write(&file, source).unwrap();
    file
}

fn build_wrapper(dir_out: &str, include: &str) {
    let mut source = String::from(WRAPPER_PREAMBLE);

    push_line(&mut source, &format!("#include \"{WRAPPER_NAME}.hpp\""));
    for xsf_header in XSF_HEADERS {
        push_line(&mut source, &format!("#include \"xsf/{xsf_header}\""));
    }

    // Put wrapper implementations in the same namespace
    push_line(&mut source, "");
    push_line(&mut source, "namespace xsf_wrapper {");
    push_line(&mut source, "");
    push_line(
        &mut source,
        "std::complex<double> complex__new(double re, double im) {
            return std::complex<double>(re, im);
        }",
    );
    push_line(
        &mut source,
        "double complex__re(std::complex<double> z) {
            return std::real(z);
        }",
    );
    push_line(
        &mut source,
        "double complex__im(std::complex<double> z) {
            return std::imag(z);
        }",
    );
    push_line(&mut source, "");

    // Generate unique function implementations for overloads
    let mut name_counts = std::collections::HashMap::new();
    for (name, types) in XSF_TYPES {
        let count = name_counts.entry(*name).or_insert(0);
        let suffix = if *count == 0 { "" } else { &count.to_string() };
        let func_decl = fmt_func(name, types, suffix);
        let call = fmt_call(name, types);
        push_line(&mut source, &format!("{func_decl} {{ return {call}; }}"));
        *count += 1;
    }

    // `assoc_legendre_p` requires special-casing
    push_line(
        &mut source,
        "double assoc_legendre_p_0(int n, int m, double z, int bc) {
            return xsf::assoc_legendre_p(xsf::assoc_legendre_unnorm, n, m, z, bc);
        }",
    );
    push_line(
        &mut source,
        "std::complex<double> assoc_legendre_p_0_1(int n, int m, std::complex<double> z, int bc) {
            return xsf::assoc_legendre_p(xsf::assoc_legendre_unnorm, n, m, z, bc);
        }",
    );
    push_line(
        &mut source,
        "double assoc_legendre_p_1(int n, int m, double z, int bc) {
            return xsf::assoc_legendre_p(xsf::assoc_legendre_norm, n, m, z, bc);
        }",
    );
    push_line(
        &mut source,
        "std::complex<double> assoc_legendre_p_1_1(int n, int m, std::complex<double> z, int bc) {
            return xsf::assoc_legendre_p(xsf::assoc_legendre_norm, n, m, z, bc);
        }",
    );

    push_line(&mut source, "");
    push_line(&mut source, "} // namespace xsf_wrapper");

    let file_cpp = format!("{dir_out}/{WRAPPER_NAME}.cpp");
    std::fs::write(&file_cpp, source).unwrap();

    let mut build = cc::Build::new();
    build
        .cpp(true)
        .prefer_clang_cl_over_msvc(true)
        .flag_if_supported("-Wno-unused-parameter")
        .flag_if_supported("-Wno-logical-op-parentheses")
        .file(file_cpp)
        .include(include);

    if build.get_compiler().is_like_msvc() {
        // windows
        build.flag("/std:c++17");
    } else {
        build.std("c++17");
    }

    build.compile(WRAPPER_NAME);
}

fn generate_bindings(dir_out: &str, header: &str) {
    // Generate allowlist pattern including numbered overloads
    let mut allowlist_functions = Vec::new();
    allowlist_functions.push("xsf_wrapper::complex__new".to_string());
    allowlist_functions.push("xsf_wrapper::complex__re".to_string());
    allowlist_functions.push("xsf_wrapper::complex__im".to_string());

    let mut name_counts = std::collections::HashMap::new();
    for (name, _) in XSF_TYPES {
        let count = name_counts.entry(*name).or_insert(0);
        let base_name = XSF_RENAME
            .iter()
            .find(|(n, _)| n == name)
            .map(|(_, r)| *r)
            .unwrap_or(name);

        if *count == 0 {
            allowlist_functions.push(format!("xsf_wrapper::{}", base_name));
        } else {
            allowlist_functions.push(format!("xsf_wrapper::{}_{}", base_name, count));
        }
        *count += 1;
    }
    allowlist_functions.push("xsf_wrapper::assoc_legendre_p_.+".to_string());

    let allowlist_pattern = allowlist_functions.join("|");

    bindgen::Builder::default()
        .header(header)
        .size_t_is_usize(true)
        .sort_semantically(true)
        .opaque_type("std::*")
        .allowlist_function(&allowlist_pattern)
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .enable_cxx_namespaces()
        .generate()
        .unwrap()
        .write_to_file(PathBuf::from(dir_out).join("bindings.rs"))
        .unwrap();
}

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    let include = format!("{manifest_dir}/xsf/include");
    let header = generate_header(&out_dir);

    println!("cargo:rerun-if-changed={include}");

    build_wrapper(&out_dir, &include);
    generate_bindings(&out_dir, &header);
}
